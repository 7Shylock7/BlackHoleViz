// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Constants
static const float PI = 3.14159265f;

// Output parameters
RWTexture2D<float4> Position;
RWTexture2D<float4> Direction;
RWTexture2D<float4> Color;
RWTexture2D<int> isComplete;

// Input parameters
TextureCube<float4> _SkyboxTexture;
Texture2D<float3> _NoiseTexture;
Texture2D<float3> _BlackbodyTexture;
float timeStep;
float escapeDistance;
float horizonRadius;
float diskMax;
float diskTemp;
float diskMult;
float starMult;

// Samplers
SamplerState sampler_Position;
SamplerState sampler_Direction;
SamplerState sampler_isComplete;
SamplerState sampler_SkyboxTexture;
SamplerState sampler_NoiseTexture;
SamplerState sampler_BlackbodyTexture;


// Pseudorandom 2D function
float Random(float2 sampleCoord)
{
    return frac(sin(dot(sampleCoord.xy, float2(12.9898,78.233)))*43758.5453123);
}

// 2D Noise function
float Noise(float2 sampleCoord) {

    // Separate integral and fractional components
    float2 i = floor(sampleCoord);
    float2 f = frac(sampleCoord);

    // Four corners of adjacent tile
    float a = Random(i);
    float b = Random(i + float2(1.0, 0.0));
    float c = Random(i + float2(0.0, 1.0));
    float d = Random(i + float2(1.0, 1.0));

    // Smooth interpolation
    float2 u = f*f*(3.0-2.0*f);

    // Mix and return
    return lerp(a, b, u.x) + 
            (c - a) * u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

// Fractional Brownian Motion for noise sampling
float SampleFBM(float2 x, float H, int numOctaves)
{
    // Thank you, as always, to Inigo Quilez for this FBM code snippet
    float G = exp2(-H);
    float f = 1.0;
    float a = 1.0;
    float t = 0.0;
    for( int i=0; i<numOctaves; i++ )
    {
        t += a*Noise(f*x);
        f *= 2.0;
        a *= G;
    }
    return t;
}

// Cartesian to Spherical coordinate conversion
float3 ToSphericalScalar(float3 cart)
{
    float r = length(cart);
    float rxz = length(cart.xz);
    float theta = atan2(rxz, cart.y);
    float phi = atan2(cart.z, cart.x);

    return float3(r, theta, phi);
}

// Cartesian to Spherical vector conversion (inputs in cartesian)
float3 ToSphericalVector(float3 origin, float3 dir)
{
    float r = length(origin);
    float rxz = length(origin.xz);

    float3x3 L = {
        origin.x / r,                        // dr/dx
        origin.y / r,                        // dr/dy
        origin.z / r,                        // dr/dz
        origin.x * origin.y / (r * r * rxz), // dtheta/dx
        -rxz / (r * r),                      // dtheta/dy
        origin.z* origin.y / (r * r * rxz),  // dtheta/dz
        -origin.z / rxz,                     // dphi/dx
        0.0,                                 // dphi/dy
        origin.x / rxz                       // dphi/dz
    };

    return mul(L, dir);
}

// Spherical to Cartesian coordinate conversion
float3 ToCartesianScalar(float3 sph)
{
    float x = sph.x * cos(sph.z) * sin(sph.y);
    float y = sph.x * cos(sph.y);
    float z = sph.x * sin(sph.z) * sin(sph.y);

    return float3(x, y, z);
}

// Spherical to Cartesian vector conversion (inputs in spherical)
float3 ToCartesianVector(float3 origin, float3 dir)
{
    float3x3 L = {
        sin(origin.y) * cos(origin.z),              // dx/dr
        origin.x * cos(origin.y) * cos(origin.z),   // dx/dtheta
        -origin.x * sin(origin.y) * sin(origin.z),  // dx/dphi
        cos(origin.y),                              // dz/dr
        -origin.x * sin(origin.y),                  // dz/dtheta
        0.0,                                        // dz/dphi
        sin(origin.y) * sin(origin.z),              // dy/dr
        origin.x* cos(origin.y)* sin(origin.z),     // dy/dtheta
        origin.x* sin(origin.y)* cos(origin.z)      // dy/dphi
    };

    return mul(L, dir);
}

// Re-map angles
void CoordinateChange(inout float3 x, inout float3 u) 
{
    // float3 cartU = ToCartesianVector(x, u);
    float3 cartX = ToCartesianScalar(x);
    x = ToSphericalScalar(cartX.xzy);
    // u = ToSphericalVector(cartX.xzy, cartU.xzy);
}

// Calculate change in k along geodesic affine parameter
void CalculateGeodesicDerivative(float3 x, float3 u, out float3 dx, out float3 du)
{
    // Pre-calculate factors
    float r = x.x;
    float rs = horizonRadius;
    float th = x.y;
    float sth = sin(th);
    float A = 1.0 - (rs / r);
    float a = sqrt(A);

    // Calculate proper time derivative
    float u0 = sqrt((A * u.x * u.x) + (u.y * u.y / (r * r)) + (u.z * u.z / (r * r * sth * sth))) / a;

    // Calculate spatial derivatives
    dx.x = A * u.x / u0;
    dx.y = u.y / (r * r * u0);
    dx.z = u.z / (r * r * sth * sth * u0);
    du.x = 
        (-u0 * rs / (2.0 * r * r)) +
        (-u.x * u.x * rs / (2.0 * u0 * r * r)) +
        (u.y * u.y / (r * r * r * u0)) + 
        (u.z * u.z / (r * r * r * sth * sth * u0));
    du.y = (u.z * u.z / (r * r * sth * sth * tan(th) * u0));
    du.z = 0.0;

    return;
}

// Runge-Kutta 4th Order integration
void RK4Step(float tStep, inout float3 x, inout float3 u)
{

    // If near the north/south poles, change coordinate system
    float margin = 0.01;
    bool coordChange = (x.y < margin*PI || x.y > (1.0 - margin)*PI);
    if(coordChange) { CoordinateChange(x, u); }

    // Calculate k-factors
    float3 dx1, du1, dx2, du2, dx3, du3, dx4, du4;
    CalculateGeodesicDerivative(x, u, dx1, du1);
    CalculateGeodesicDerivative(x + dx1 * (tStep / 2.0), u + du1 * (tStep / 2.0), dx2, du2);
    CalculateGeodesicDerivative(x + dx2 * (tStep / 2.0), u + du2 * (tStep / 2.0), dx3, du3);
    CalculateGeodesicDerivative(x + dx3 * tStep,         u + du3 * tStep,         dx4, du4);

    // Calculate full update
    x += (tStep / 6.0) * (dx1 + 2.0 * dx2 + 2.0 * dx3 + dx4);
    u += (tStep / 6.0) * (du1 + 2.0 * du2 + 2.0 * du3 + du4);

    // Return to original coordinate system if needed
    if(coordChange) { CoordinateChange(x, u); }

    return;
}

// Generate affine parameter step size
float CalculateStepSize(float3 x, float3 u)
{
    float rs = horizonRadius;

    if (abs(x.x) < 2.0 * rs)
    {
        // Near horizon regime
        return timeStep;
    }
    else
    {
        if (u.x * x.x > 0.0)
        {
            // Far from horizon, receding
            return max(timeStep * x.x * x.x, timeStep);
        }
        else
        {
            // Far from horizon, approaching
            return max(timeStep * (abs(x.x) - (2.0 * rs)), timeStep);
        }
    }
}

// Check if geodesic inevitably crosses horizon
bool HorizonCheck(float3 x, float3 u)
{

    if(abs(x.x) < 1.5 * horizonRadius) {
        return true;
    }

    // TO DO: Use constants of motion to check if geodesic can be thrown out at infinity

   // Pre-calculate factors
   float r = x.x;
   float rs = horizonRadius;
   float th = x.y;
   float sth = sin(th);
   float A = 1.0 - (rs / r);
   float a = sqrt(A);

   // Calculate motion constants
   float Esq = ((A * u.x * u.x) + (u.y * u.y / (r * r)) + (u.z * u.z / (r * r * sth * sth)));
   float uphi = u.z / (sqrt(Esq) * sth * sth);
   float L = r * r * uphi;
   float C = L*L / Esq;

    // Check horizon conditions
    if (C > 27.0 * rs * rs / 4.0)
    {
       return r < 1.5 * horizonRadius;
    }
    else
    {
       // FIX THIS
    //    return u.x > 0.0;
       return false;
    }
}

// Check if path will cross accretion disk
bool DiskCheck(float3 x, float3 xLast)
{
    // Check for hemisphere change
    float newTh = (x.y % PI) - (PI / 2.0);
    float oldTh = (xLast.y % PI) - (PI / 2.0);
    if (newTh * oldTh > 0.0) { return false; }

    // Check if within accretion disk bounds
    // float r_isco = 3.0 * horizonRadius;
    float r_isco = 1.0 * horizonRadius;
    float r_ave = (x.x + xLast.x) / 2.0;
    if (r_ave < r_isco || r_ave > diskMax) { return false; }

    // If passed, return true
    return true;
}

// Get color of accretion disk
float4 GetDiskColor(float3 x, float3 xLast)
{
    // Calculate noise texture UV coordinates
    float2 uv;
    float rEval = (x.x + xLast.x) / 2.0;
    float phEval = (x.z + xLast.z) / 2.0;
    uv.x = phEval / (2.0 * PI);
    uv.y = (abs(rEval) - 3.0 * horizonRadius) / (diskMax - 3.0 * horizonRadius);

    // Sample noise texture
    // float4 texColor = _NoiseTexture.SampleLevel(sampler_NoiseTexture, uv, 0).xyzx;
    float2 s;
    float drift = PI/2.0;
    s.x = rEval*cos(phEval + drift*uv.y);
    s.y = rEval*sin(phEval + drift*uv.y);
    float4 texColor = SampleFBM(s, 1.0, 4).xxxx;
    texColor /= 1.5;

    // Reduce intensity over distance
    float falloff = uv.y < 0.0 ? exp(10.0*uv.y) : max((1.0 - uv.y), 0.0);
    texColor *= falloff;
    // texColor *= max((1.0 - uv.y), 0.0);

    // Calculate temperature
    float rFactor = pow(abs(3.0 * horizonRadius / rEval), 0.75);
    float T = diskTemp * rFactor;

    // Calculate doppler shift
    float v = sqrt(horizonRadius / (2.0 * rEval));
    float gamma = 1.0 / sqrt(1.0 - (v * v));
    float3 xDiff = xLast - x;
    float incidence = xDiff.z * rEval / length(xDiff * float3(1.0, rEval, rEval));
    float shift = gamma * (1.0 + v * incidence);

    // Relativistic beaming
    texColor *= shift * shift;

    // Calculate gravitational redshift
    shift *= sqrt(1 - (horizonRadius / rEval));

    // Sample blackbody texture
    uv.x = (shift - 0.5) / (2.0 - 0.5);
    uv.y = (T - 1000.0) / (10000.0 - 1000.0);
    float3 bbColor = _BlackbodyTexture.SampleLevel(sampler_BlackbodyTexture, uv, 0);

    // Weight by noise strength and multiplier
    float4 outColor = texColor.xxxx * float4(bbColor.xyz, 1.0) * float4(diskMult.xxx, 1.0);

    // Return adjusted color
    return outColor;
}

// Blend transparency and background colors
float4 Blend(float4 foreColor, float4 backColor)
{
    // Blend using previous color's alpha
    float4 outColor = foreColor + backColor * (1.0 - foreColor.w);
    return outColor;
}

[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Break if already failed bounds check
    if (isComplete[id.xy] == 1) { return; }

    // Propagate ray
    float3 x =  Position[id.xy].xyz;
    float3 u = Direction[id.xy].xyz;
    float3 xLast = x;
    float dt = CalculateStepSize(x, u);
    RK4Step(dt, x, u);

    // Write back position and direction
    Position[id.xy]  = float4(x.xyz, 0.0);
    Direction[id.xy] = float4(u.xyz, 0.0);

    // Check for disk crossing
    if (DiskCheck(x, xLast))
    {
        // Save color from accretion disk noise function
        Color[id.xy] = Blend(Color[id.xy], GetDiskColor(x, xLast));

        // Set complete flag
        //isComplete[id.xy] = 1;
    }

    // Check for horizon condition
    if (HorizonCheck(x, u))
    {
        // Blend black with previous color
        Color[id.xy] = Blend(Color[id.xy], float4(0.0, 0.0, 0.0, 1.0));

        // Set complete flag
        isComplete[id.xy] = 1;
    }

    // Check for escape condition
    if (abs(x.x) > escapeDistance * horizonRadius)
    {
        // Evaluate skybox texture
        float3 outRay = ToCartesianScalar(x.xyz).xyz;
        outRay.z *= -1.0;
        float4 skyboxColor = _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, outRay, 0);
        skyboxColor *= float4(starMult.xxx, 1.0);

        // Blend with previous color value
        Color[id.xy] = Blend(Color[id.xy], skyboxColor);

        // Set complete flag
        isComplete[id.xy] = 1;
    }


}
