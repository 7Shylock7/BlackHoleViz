// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Output textures
RWTexture2D<float4> State;

// Input parameters
float timeStep;
float time;

// Calculate all required state derivatives
void CalculateSpatialDerivatives(int2 coord, float dl, out float4 dfdx, out float4 dfdy, out float4 dfdxy, out float4 dfdxx, out float4 dfdyy) {

    // Read state at stencil locations
    float4 cState =  State[coord];
    float4 uState =  State[coord + int2(0,   1)];
    float4 dState =  State[coord + int2(0,  -1)];
    float4 rState =  State[coord + int2(1,   0)];
    float4 lState =  State[coord + int2(-1,  0)];
    float4 urState = State[coord + int2(1,   1)];
    float4 ulState = State[coord + int2(1,  -1)];
    float4 drState = State[coord + int2(-1,  1)];
    float4 dlState = State[coord + int2(-1, -1)];

    // First order derivatives
    dfdx = (rState - lState) / (2.0 * dl);
    dfdy = (uState - dState) / (2.0 * dl);

    // Second order derivatives
    dfdxx = (rState + lState - 2.0 * cState) / (dl * dl);
    dfdyy = (uState + dState - 2.0 * cState) / (dl * dl);

    // Mixed derivatives
    dfdxy = (urState - drState + dlState - ulState) / (4.0 * dl * dl);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Get the dimensions of the RenderTexture
    uint width, height;
    State.GetDimensions(width, height);

    // Calculate position
    float2 fid = float2(id.xy);
    float2 r = 2.0 * float2((fid.x / width) - 0.5, (fid.y / height) - 0.5);

    // Calculate spatial derivatives
    float4 state = State[id.xy];
    float4 dfdx, dfdy, dfdxy, dfdxx, dfdyy;
    CalculateSpatialDerivatives(id.xy, 1.0, dfdx, dfdy, dfdxy, dfdxx, dfdyy);

    // Density update
    float ps = length(r) > 0.1 ? 1.0 : 0.0;
    float dpdt = -(dfdx.x * state.y + dfdy.x * state.z + state.x * (dfdx.y + dfdy.z)) + ps;

    // Flow update
    float2 g = length(r) > 0.1 ? 0.0001 / r : float2(0.0, 0.0);
    float dudt = -(state.y * dfdx.y + state.z * dfdx.y) - g.x;
    float dvdt = -(state.y * dfdy.y + state.z * dfdy.y) - g.y;

    // Update state
    state += timeStep * float4(dpdt, dudt, dvdt, 0.0);
    if (state.x < 0.0) { state.x = 0.0; }
    State[id.xy] = state;

}
